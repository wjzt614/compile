///
/// @file IRGenerator.cpp
/// @brief AST遍历产生线性IR的源文件
/// @author zenglj (zenglj@live.com)
/// @version 1.1
/// @date 2024-11-23
///
/// @copyright Copyright (c) 2024
///
/// @par 修改日志:
/// <table>
/// <tr><th>Date       <th>Version <th>Author  <th>Description
/// <tr><td>2024-09-29 <td>1.0     <td>zenglj  <td>新建
/// <tr><td>2024-11-23 <td>1.1     <td>zenglj  <td>表达式版增强
/// </table>
///
#include <cstdint>
#include <cstdio>
#include <unordered_map>
#include <vector>
#include <iostream>
#include <functional>

#include "AST.h"
#include "Common.h"
#include "Function.h"
#include "IRCode.h"
#include "IRGenerator.h"
#include "Module.h"
#include "EntryInstruction.h"
#include "LabelInstruction.h"
#include "ExitInstruction.h"
#include "FuncCallInstruction.h"
#include "BinaryInstruction.h"
#include "MoveInstruction.h"
#include "GotoInstruction.h"
#include "UnaryInstruction.h"
#include "ArrayType.h"
#include "PointerType.h"

/// @brief 构造函数
/// @param _root AST的根
/// @param _module 符号表
IRGenerator::IRGenerator(ast_node * _root, Module * _module) : root(_root), module(_module)
{
    /* 叶子节点 */
    ast2ir_handlers[ast_operator_type::AST_OP_LEAF_LITERAL_UINT] = &IRGenerator::ir_leaf_node_uint;
    ast2ir_handlers[ast_operator_type::AST_OP_LEAF_VAR_ID] = &IRGenerator::ir_leaf_node_var_id;
    ast2ir_handlers[ast_operator_type::AST_OP_LEAF_TYPE] = &IRGenerator::ir_leaf_node_type;

    /* 表达式运算， 加减 */
    ast2ir_handlers[ast_operator_type::AST_OP_SUB] = &IRGenerator::ir_sub;
    ast2ir_handlers[ast_operator_type::AST_OP_ADD] = &IRGenerator::ir_add;

    /* 单目运算符 - */
    ast2ir_handlers[ast_operator_type::AST_OP_NEG] = &IRGenerator::ir_neg;

    /* 表达式运算， 乘、除、取余 */
    ast2ir_handlers[ast_operator_type::AST_OP_MUL] = &IRGenerator::ir_mul;
    ast2ir_handlers[ast_operator_type::AST_OP_DIV] = &IRGenerator::ir_div;
    ast2ir_handlers[ast_operator_type::AST_OP_MOD] = &IRGenerator::ir_mod;

    /* 关系运算符 */
    ast2ir_handlers[ast_operator_type::AST_OP_LT] = &IRGenerator::ir_relational_op;
    ast2ir_handlers[ast_operator_type::AST_OP_LE] = &IRGenerator::ir_relational_op;
    ast2ir_handlers[ast_operator_type::AST_OP_GT] = &IRGenerator::ir_relational_op;
    ast2ir_handlers[ast_operator_type::AST_OP_GE] = &IRGenerator::ir_relational_op;
    ast2ir_handlers[ast_operator_type::AST_OP_EQ] = &IRGenerator::ir_relational_op;
    ast2ir_handlers[ast_operator_type::AST_OP_NE] = &IRGenerator::ir_relational_op;

    /* 逻辑运算符 */
    ast2ir_handlers_with_labels[ast_operator_type::AST_OP_LOGICAL_AND] = &IRGenerator::ir_logical_and;
    ast2ir_handlers_with_labels[ast_operator_type::AST_OP_LOGICAL_OR] = &IRGenerator::ir_logical_or;
    ast2ir_handlers_with_labels[ast_operator_type::AST_OP_LOGICAL_NOT] = &IRGenerator::ir_logical_not;

    /* 语句 */
    ast2ir_handlers[ast_operator_type::AST_OP_ASSIGN] = &IRGenerator::ir_assign;
    ast2ir_handlers[ast_operator_type::AST_OP_RETURN] = &IRGenerator::ir_return;

    /* 控制流语句 */
    ast2ir_handlers[ast_operator_type::AST_OP_IF] = &IRGenerator::ir_if;
    ast2ir_handlers[ast_operator_type::AST_OP_IF_ELSE] = &IRGenerator::ir_if_else;
    ast2ir_handlers[ast_operator_type::AST_OP_WHILE] = &IRGenerator::ir_while;
    ast2ir_handlers[ast_operator_type::AST_OP_BREAK] = &IRGenerator::ir_break;
    ast2ir_handlers[ast_operator_type::AST_OP_CONTINUE] = &IRGenerator::ir_continue;

    /* 函数调用 */
    ast2ir_handlers[ast_operator_type::AST_OP_FUNC_CALL] = &IRGenerator::ir_function_call;

    /* 函数定义 */
    ast2ir_handlers[ast_operator_type::AST_OP_FUNC_DEF] = &IRGenerator::ir_function_define;
    ast2ir_handlers[ast_operator_type::AST_OP_FUNC_FORMAL_PARAMS] = &IRGenerator::ir_function_formal_params;
    ast2ir_handlers[ast_operator_type::AST_OP_FUNC_FORMAL_PARAM_ARRAY] = &IRGenerator::ir_function_formal_params;

    /* 变量定义语句 */
    ast2ir_handlers[ast_operator_type::AST_OP_DECL_STMT] = &IRGenerator::ir_declare_statment;
    ast2ir_handlers[ast_operator_type::AST_OP_VAR_DECL] = &IRGenerator::ir_variable_declare;
    ast2ir_handlers[ast_operator_type::AST_OP_VAR_DEF_INIT] = &IRGenerator::ir_variable_declare_init;

    /* 数组相关 */
    ast2ir_handlers[ast_operator_type::AST_OP_ARRAY_DEF] = &IRGenerator::ir_array_def;
    ast2ir_handlers[ast_operator_type::AST_OP_ARRAY_ACCESS] = &IRGenerator::ir_array_access;

    /* 添加对数组初始化的支持 */
    ast2ir_handlers[ast_operator_type::AST_OP_ARRAY_INIT_LIST] = &IRGenerator::ir_array_init_list;
    ast2ir_handlers[ast_operator_type::AST_OP_ARRAY_INIT_ELEM] = &IRGenerator::ir_array_init_elem;
    ast2ir_handlers[ast_operator_type::AST_OP_ARRAY_INIT_EMPTY] = &IRGenerator::ir_array_init_empty;

    /* 语句块 */
    ast2ir_handlers[ast_operator_type::AST_OP_BLOCK] = &IRGenerator::ir_block;

    /* 编译单元 */
    ast2ir_handlers[ast_operator_type::AST_OP_COMPILE_UNIT] = &IRGenerator::ir_compile_unit;
}

/// @brief 遍历抽象语法树产生线性IR，保存到IRCode中
/// @param root 抽象语法树
/// @param IRCode 线性IR
/// @return true: 成功 false: 失败
bool IRGenerator::run()
{
    ast_node * node;

    // 从根节点进行遍历
    node = ir_visit_ast_node(root);

    return node != nullptr;
}

/// @brief 根据AST的节点运算符查找对应的翻译函数并执行翻译动作
/// @param node AST节点
/// @return 成功返回node节点，否则返回nullptr
ast_node * IRGenerator::ir_visit_ast_node(ast_node * node, LabelInstruction * trueLabel, LabelInstruction * falseLabel)
{
    // 空节点
    if (nullptr == node) {
        return nullptr;
    }

    bool result;

    // 首先检查带标签的处理函数
    std::unordered_map<ast_operator_type, ast2ir_handler_with_labels_t>::const_iterator pIterWithLabels;
    pIterWithLabels = ast2ir_handlers_with_labels.find(node->node_type);
    if (pIterWithLabels != ast2ir_handlers_with_labels.end()) {
        // 找到带标签的处理函数
        result = (this->*(pIterWithLabels->second))(node, trueLabel, falseLabel);
    } else {
        // 检查不带标签的处理函数
        std::unordered_map<ast_operator_type, ast2ir_handler_t>::const_iterator pIter;
        pIter = ast2ir_handlers.find(node->node_type);
        if (pIter == ast2ir_handlers.end()) {
            // 没有找到，则说明当前不支持
            result = (this->ir_default)(node);
        } else {
            result = (this->*(pIter->second))(node);
        }
    }

    if (!result) {
        // 语义解析错误，则出错返回
        node = nullptr;
    }

    return node;
}

/// @brief 未知节点类型的节点处理
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_default(ast_node * node)
{
    // 未知的节点
    printf("Unkown node(%d)\n", (int) node->node_type);
    return true;
}

/// @brief 编译单元AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_compile_unit(ast_node * node)
{
    module->setCurrentFunction(nullptr);

    // 保存需要初始化的全局变量和初始值
    std::vector<std::pair<std::string, int32_t>> globalVarInits;

    // 用于跟踪已处理的全局变量，防止重复声明
    std::unordered_set<std::string> processedGlobalVars;

    for (auto son: node->sons) {
        // 检查是否是全局变量声明
        if (son->node_type == ast_operator_type::AST_OP_DECL_STMT) {

            for (auto decl: son->sons) {
                if (decl->sons.size() >= 2) {
                    // ast_node* type_node = decl->sons[0];
                    ast_node * id_node = nullptr;

                    // 检查是否是数组定义
                    if (decl->sons[1]->node_type == ast_operator_type::AST_OP_ARRAY_DEF) {
                        id_node = decl->sons[1]->sons[0];

                        // 检查变量是否已经处理过，防止重复声明
                        if (processedGlobalVars.find(id_node->name) != processedGlobalVars.end()) {
                            continue;
                        }

                        ast_node * dims_node = decl->sons[1]->sons[1];

                        // 创建一个向量存储所有维度大小
                        std::vector<uint32_t> dims;

                        // 检查数组维度节点的类型
                        if (dims_node->node_type == ast_operator_type::AST_OP_ARRAY_DIMS) {
                            // 如果是AST_OP_ARRAY_DIMS类型，遍历所有子节点获取各个维度

                            // 遍历所有维度节点
                            for (auto dim_node: dims_node->sons) {
                                if (dim_node->node_type == ast_operator_type::AST_OP_LEAF_LITERAL_UINT) {
                                    dims.push_back(dim_node->integer_val);
                                }
                            }
                        } else if (dims_node->node_type == ast_operator_type::AST_OP_LEAF_LITERAL_UINT) {
                            // 如果是单个维度
                            dims.push_back(dims_node->integer_val);
                        }

                        // 如果没有获取到任何维度信息，报错
                        if (dims.empty()) {
                            continue;
                        }

                        // 反向打印所有维度进行调试
                        std::string dims_str = "[";
                        for (size_t i = 0; i < dims.size(); i++) {
                            dims_str += std::to_string(dims[i]);
                            if (i < dims.size() - 1) {
                                dims_str += "][";
                            }
                        }
                        dims_str += "]";
                        // 创建数组类型
                        Type * array_type = ArrayType::get(IntegerType::getTypeInt(), dims);

                        // 创建全局数组变量
                        module->createGlobalArray(id_node->name, array_type);

                        // 标记为已处理
                        processedGlobalVars.insert(id_node->name);
                    }
                }
            }
        }
    }

    // 然后正常处理所有编译单元节点
    for (auto son: node->sons) {
        // 遍历编译单元，要么是函数定义，要么是语句
        ast_node * son_node = ir_visit_ast_node(son);
        if (!son_node) {
            // TODO 自行追加语义错误处理
            return false;
        }

        // 检查是否是全局变量初始化
        if (son->node_type == ast_operator_type::AST_OP_DECL_STMT) {
            for (auto decl: son->sons) {
                if (decl->sons.size() >= 2 && decl->sons[1]->node_type == ast_operator_type::AST_OP_VAR_DEF_INIT) {
                    ast_node * id_node = decl->sons[1]->sons[0];
                    ast_node * expr_node = decl->sons[1]->sons[1];

                    // 检查变量初始化节点是否有整数值（由ir_variable_declare_init设置）
                    if (decl->sons[1]->integer_val != 0 ||
                        expr_node->node_type == ast_operator_type::AST_OP_LEAF_LITERAL_UINT ||
                        (expr_node->node_type == ast_operator_type::AST_OP_NEG && expr_node->sons.size() > 0 &&
                         expr_node->sons[0]->node_type == ast_operator_type::AST_OP_LEAF_LITERAL_UINT)) {

                        // 获取初始化值（由ir_variable_declare_init设置到节点）
                        int32_t initValue = decl->sons[1]->integer_val;

                        // 保存全局变量名和初始值
                        globalVarInits.push_back({id_node->name, initValue});
                    }
                }
            }
        }
    }

    // 如果有全局变量初始化，则在main函数的入口处添加初始化代码
    if (!globalVarInits.empty()) {
        // 查找main函数
        Function * mainFunc = module->findFunction("main");
        if (mainFunc) {
            // 获取main函数的IR代码列表
            InterCode & irCode = mainFunc->getInterCode();

            // 创建临时的指令列表，用于存储全局变量初始化指令
            std::vector<Instruction *> initInsts;

            // 创建全局变量初始化指令
            for (auto & [varName, initValue]: globalVarInits) {
                // 查找全局变量
                Value * globalVar = module->findVarValue(varName);
                if (globalVar) {
                    // 创建常量值
                    ConstInt * constVal = module->newConstInt(initValue);

                    // 创建移动指令，将初始值赋给全局变量
                    MoveInstruction * moveInst = new MoveInstruction(mainFunc, globalVar, constVal);

                    // 添加到临时指令列表
                    initInsts.push_back(moveInst);
                }
            }

            // 获取原始指令列表
            std::vector<Instruction *> & insts = irCode.getInsts();

            // 找到EntryInstruction的位置
            size_t entryPos = 0;
            for (size_t i = 0; i < insts.size(); ++i) {
                if (dynamic_cast<EntryInstruction *>(insts[i])) {
                    entryPos = i;
                    break;
                }
            }

            // 在EntryInstruction后插入全局变量初始化指令
            if (entryPos < insts.size()) {
                insts.insert(insts.begin() + entryPos + 1, initInsts.begin(), initInsts.end());
            }
        }
    }

    return true;
}

/// @brief 函数定义AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_function_define(ast_node * node)
{
    bool result;

    // 创建一个函数，用于当前函数处理
    if (module->getCurrentFunction()) {
        // 函数中嵌套定义函数，这是不允许的，错误退出
        // TODO 自行追加语义错误处理
        return false;
    }

    // 函数定义的AST包含四个孩子
    // 第一个孩子：函数返回类型
    // 第二个孩子：函数名字
    // 第三个孩子：形参列表
    // 第四个孩子：函数体即block
    ast_node * type_node = node->sons[0];
    ast_node * name_node = node->sons[1];
    ast_node * param_node = node->sons[2];
    ast_node * block_node = node->sons[3];

    // 创建一个新的函数定义
    Function * newFunc = module->newFunction(name_node->name, type_node->type);
    if (!newFunc) {
        // 新定义的函数已经存在，则失败返回。
        // TODO 自行追加语义错误处理
        return false;
    }

    // 当前函数设置有效，变更为当前的函数
    module->setCurrentFunction(newFunc);

    // 进入函数的作用域
    module->enterScope();

    // 获取函数的IR代码列表，用于后面追加指令用，注意这里用的是引用传值
    InterCode & irCode = newFunc->getInterCode();

    // 这里也可增加一个函数入口Label指令，便于后续基本块划分

    // 创建并加入Entry入口指令
    irCode.addInst(new EntryInstruction(newFunc));

    // 创建出口指令并不加入出口指令，等函数内的指令处理完毕后加入出口指令
    LabelInstruction * exitLabelInst = new LabelInstruction(newFunc);

    // 函数出口指令保存到函数信息中，因为在语义分析函数体时return语句需要跳转到函数尾部，需要这个label指令
    newFunc->setExitLabel(exitLabelInst);

    // 遍历形参，没有IR指令，不需要追加
    result = ir_function_formal_params(param_node);
    if (!result) {
        // 形参解析失败
        // TODO 自行追加语义错误处理
        return false;
    }
    node->blockInsts.addInst(param_node->blockInsts);

    // 新建一个Value，用于保存函数的返回值，如果没有返回值可不用申请
    LocalVariable * retValue = nullptr;
    if (!type_node->type->isVoidType()) {

        // 保存函数返回值变量到函数信息中，在return语句翻译时需要设置值到这个变量中
        retValue = static_cast<LocalVariable *>(module->newVarValue(type_node->type));
    }
    newFunc->setReturnValue(retValue);

    // 如果是main函数，初始化返回值为0
    if (name_node->name == "main" && retValue != nullptr) {
        // 创建常量0
        ConstInt * zeroConst = module->newConstInt(0);

        // 创建移动指令，将0赋值给返回值变量
        MoveInstruction * moveInst = new MoveInstruction(module->getCurrentFunction(), retValue, zeroConst);
        node->blockInsts.addInst(moveInst);
    }

    // 函数内已经进入作用域，内部不再需要做变量的作用域管理
    block_node->needScope = false;

    // 遍历block
    result = ir_block(block_node);
    if (!result) {
        // block解析失败
        // TODO 自行追加语义错误处理
        return false;
    }

    // IR指令追加到当前的节点中
    node->blockInsts.addInst(block_node->blockInsts);

    // 此时，所有指令都加入到当前函数中，也就是node->blockInsts

    // node节点的指令移动到函数的IR指令列表中
    irCode.addInst(node->blockInsts);

    // 添加函数出口Label指令，主要用于return语句跳转到这里进行函数的退出
    irCode.addInst(exitLabelInst);

    // 函数出口指令
    irCode.addInst(new ExitInstruction(newFunc, retValue));

    // 恢复成外部函数
    module->setCurrentFunction(nullptr);

    // 退出函数的作用域
    module->leaveScope();

    return true;
}

/// @brief 形式参数AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_function_formal_params(ast_node * node)
{
    // 每个形参变量都创建对应的临时变量，用于表达实参转递的值
    // 而真实的形参则创建函数内的局部变量。
    // 然后产生赋值指令，用于把表达实参值的临时变量拷贝到形参局部变量上。
    // 请注意这些指令要放在Entry指令后面，因此处理的先后上要注意。

    // 获取当前正在处理的函数
    Function * currentFunc = module->getCurrentFunction();
    if (!currentFunc) {
        return false;
    }

    // 遍历所有形参
    for (auto son: node->sons) {
        // 检查形参节点类型
        if (son->node_type == ast_operator_type::AST_OP_FUNC_FORMAL_PARAM) {
            // 普通形参节点包含两个子节点：类型节点和名称节点
            if (son->sons.size() != 2) {
                continue;
            }

            ast_node * type_node = son->sons[0];
            ast_node * name_node = son->sons[1];

            // 获取形参类型和名称
            Type * paramType = type_node->type;
            std::string paramName = name_node->name;

            // 创建形参对应的FormalParam对象
            FormalParam * formalParam = new FormalParam(paramType, paramName);
            currentFunc->getParams().push_back(formalParam);

            // 创建局部变量，用于存储形参的值
            LocalVariable * localVar = static_cast<LocalVariable *>(module->newVarValue(paramType, paramName));

            // 创建移动指令，将形参值移动到局部变量
            MoveInstruction * moveInst = new MoveInstruction(currentFunc, localVar, formalParam);
            node->blockInsts.addInst(moveInst);
        } else if (son->node_type == ast_operator_type::AST_OP_FUNC_FORMAL_PARAM_ARRAY) {
            // 数组形参节点
            if (son->sons.size() != 2) {
                continue;
            }

            // 数组形参的名称保存在节点的name属性中
            std::string paramName = son->name;

            // 获取数组类型，已经在AST创建时设置好了
            Type * arrayType = son->type;

            // 创建形参对应的FormalParam对象
            FormalParam * formalParam = new FormalParam(arrayType, paramName);
            currentFunc->getParams().push_back(formalParam);

            // 创建局部变量，用于存储形参的值
            // 注意：数组形参实际上是指针，只需要分配指针大小的空间
            LocalVariable * localVar = static_cast<LocalVariable *>(module->newVarValue(arrayType, paramName));

            // 创建移动指令，将形参值移动到局部变量
            MoveInstruction * moveInst = new MoveInstruction(currentFunc, localVar, formalParam);
            node->blockInsts.addInst(moveInst);
        }
    }

    return true;
}

/// @brief 函数调用AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_function_call(ast_node * node)
{
    std::vector<Value *> realParams;

    // 获取当前正在处理的函数
    Function * currentFunc = module->getCurrentFunction();

    // 函数调用的节点包含两个节点：
    // 第一个节点：函数名节点
    // 第二个节点：实参列表节点

    std::string funcName = node->sons[0]->name;
    // int64_t lineno = node->sons[0]->line_no;

    ast_node * paramsNode = node->sons[1];

    // 根据函数名查找函数，看是否存在。若不存在则出错
    // 这里约定函数必须先定义后使用
    auto calledFunction = module->findFunction(funcName);
    if (nullptr == calledFunction) {
        return false;
    }

    // 当前函数存在函数调用
    currentFunc->setExistFuncCall(true);

    // 如果没有孩子，也认为是没有参数
    if (!paramsNode->sons.empty()) {

        int32_t argsCount = (int32_t) paramsNode->sons.size();

        // 当前函数中调用函数实参个数最大值统计，实际上是统计实参传参需在栈中分配的大小
        // 因为目前的语言支持的int和float都是四字节的，只统计个数即可
        if (argsCount > currentFunc->getMaxFuncCallArgCnt()) {
            currentFunc->setMaxFuncCallArgCnt(argsCount);
        }

        // 遍历参数列表，孩子是表达式
        // 这里自左往右计算表达式
        for (size_t i = 0; i < paramsNode->sons.size(); i++) {
            ast_node * son = paramsNode->sons[i];

            // 遍历Block的每个语句，进行显示或者运算
            ast_node * temp = ir_visit_ast_node(son);
            if (!temp) {
                return false;
            }

            // 检查形参类型，如果是数组类型，确保实参也是数组类型
            if (i < calledFunction->getParams().size()) {
                Type * paramType = calledFunction->getParams()[i]->getType();
                if (paramType->isArrayType() && son->node_type == ast_operator_type::AST_OP_ARRAY_ACCESS) {
                    // 如果是数组参数，确保实参保留了数组类型信息
                }
            }

            realParams.push_back(temp->val);
            node->blockInsts.addInst(temp->blockInsts);
        }
    }

    // TODO 这里请追加函数调用的语义错误检查，这里只进行了函数参数的个数检查等，其它请自行追加。
    if (realParams.size() != calledFunction->getParams().size()) {
        // 函数参数的个数不一致，语义错误
        return false;
    }

    // 返回调用有返回值，则需要分配临时变量，用于保存函数调用的返回值
    Type * type = calledFunction->getReturnType();

    FuncCallInstruction * funcCallInst = new FuncCallInstruction(currentFunc, calledFunction, realParams, type);

    // 创建函数调用指令
    node->blockInsts.addInst(funcCallInst);

    // 函数调用结果Value保存到node中，可能为空，上层节点可利用这个值
    node->val = funcCallInst;

    return true;
}

/// @brief 语句块（含函数体）AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_block(ast_node * node)
{
    // 进入作用域
    if (node->needScope) {
        module->enterScope();
    }

    std::vector<ast_node *>::iterator pIter;
    for (pIter = node->sons.begin(); pIter != node->sons.end(); ++pIter) {

        // 遍历Block的每个语句，进行显示或者运算
        ast_node * temp = ir_visit_ast_node(*pIter);
        if (!temp) {
            return false;
        }

        node->blockInsts.addInst(temp->blockInsts);
    }

    // 离开作用域
    if (node->needScope) {
        module->leaveScope();
    }

    return true;
}

/// @brief 整数加法AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_add(ast_node * node)
{
    ast_node * src1_node = node->sons[0];
    ast_node * src2_node = node->sons[1];

    // 加法节点，左结合，先计算左节点，后计算右节点

    // 加法的左边操作数
    ast_node * left = ir_visit_ast_node(src1_node);
    if (!left) {
        // 某个变量没有定值
        return false;
    }

    // 加法的右边操作数
    ast_node * right = ir_visit_ast_node(src2_node);
    if (!right) {
        // 某个变量没有定值
        return false;
    }

    // 这里只处理整型的数据，如需支持实数，则需要针对类型进行处理

    BinaryInstruction * addInst = new BinaryInstruction(module->getCurrentFunction(),
                                                        IRInstOperator::IRINST_OP_ADD_I,
                                                        left->val,
                                                        right->val,
                                                        IntegerType::getTypeInt());

    // 创建临时变量保存IR的值，以及线性IR指令
    node->blockInsts.addInst(left->blockInsts);
    node->blockInsts.addInst(right->blockInsts);
    node->blockInsts.addInst(addInst);

    node->val = addInst;

    return true;
}

/// @brief 整数减法AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_sub(ast_node * node)
{
    ast_node * src1_node = node->sons[0];
    ast_node * src2_node = node->sons[1];

    // 加法节点，左结合，先计算左节点，后计算右节点

    // 加法的左边操作数
    ast_node * left = ir_visit_ast_node(src1_node);
    if (!left) {
        // 某个变量没有定值
        return false;
    }

    // 加法的右边操作数
    ast_node * right = ir_visit_ast_node(src2_node);
    if (!right) {
        // 某个变量没有定值
        return false;
    }

    // 这里只处理整型的数据，如需支持实数，则需要针对类型进行处理

    BinaryInstruction * subInst = new BinaryInstruction(module->getCurrentFunction(),
                                                        IRInstOperator::IRINST_OP_SUB_I,
                                                        left->val,
                                                        right->val,
                                                        IntegerType::getTypeInt());

    // 创建临时变量保存IR的值，以及线性IR指令
    node->blockInsts.addInst(left->blockInsts);
    node->blockInsts.addInst(right->blockInsts);
    node->blockInsts.addInst(subInst);

    node->val = subInst;

    return true;
}

/// @brief 赋值AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_assign(ast_node * node)
{
    ast_node * son1_node = node->sons[0];
    ast_node * son2_node = node->sons[1];

    // 赋值节点，自右往左运算

    // 赋值运算符的右侧操作数
    ast_node * right = ir_visit_ast_node(son2_node);
    if (!right) {
        // 某个变量没有定值
        return false;
    }

    // 赋值运算符的左侧操作数
    ast_node * left = ir_visit_ast_node(son1_node);
    if (!left) {
        // 某个变量没有定值
        // 这里缺省设置变量不存在则创建，因此这里不会错误
        return false;
    }
    
    // 检查是否是const变量，const变量不能被赋值（除了初始化）
    if (left->val && left->val->isConst()) {
        // 常量不能被赋值
        printf("Error: Cannot assign to const variable\n");
        return false;
    }

    // 获取当前函数
    Function * currentFunc = module->getCurrentFunction();

    // 创建临时变量保存IR的值，以及线性IR指令
    node->blockInsts.addInst(right->blockInsts);
    node->blockInsts.addInst(left->blockInsts);

    // 检查是否是数组元素赋值
    if (son1_node->node_type == ast_operator_type::AST_OP_ARRAY_ACCESS) {
        // 对于数组元素赋值，left->val 是一个指针
        // 创建存储指令：*ptr = value
        MoveInstruction * storeInst = new MoveInstruction(currentFunc,
                                                          left->val,  // 目标地址
                                                          right->val, // 值
                                                          1           // 表示这是一个存储操作
        );

        node->blockInsts.addInst(storeInst);
    } else {
        // 普通变量赋值
        MoveInstruction * movInst = new MoveInstruction(currentFunc, left->val, right->val);
        node->blockInsts.addInst(movInst);
    }

    // 这里假定赋值的类型是一致的
    node->val = right->val;

    return true;
}

bool IRGenerator::ir_neg(ast_node * node)
{
    ast_node * src_node = node->sons[0];

    // 单目运算符 - 的操作数
    ast_node * operand = ir_visit_ast_node(src_node);
    if (!operand) {
        // 操作数无效
        return false;
    }

    // 这里只处理整型的数据，如需支持实数，则需要针对类型进行处理
    UnaryInstruction * negInst = new UnaryInstruction(module->getCurrentFunction(),
                                                      IRInstOperator::IRINST_OP_NEG_I,
                                                      operand->val,
                                                      IntegerType::getTypeInt());

    // 创建临时变量保存IR的值，以及线性IR指令
    node->blockInsts.addInst(operand->blockInsts);
    node->blockInsts.addInst(negInst);

    node->val = negInst;

    return true;
}

bool IRGenerator::ir_mul(ast_node * node)
{
    ast_node * left = node->sons[0];
    ast_node * right = node->sons[1];

    ast_node * leftOperand = ir_visit_ast_node(left);
    ast_node * rightOperand = ir_visit_ast_node(right);
    if (!leftOperand || !rightOperand) {
        return false;
    }

    BinaryInstruction * mulInst = new BinaryInstruction(module->getCurrentFunction(),
                                                        IRInstOperator::IRINST_OP_MUL_I,
                                                        leftOperand->val,
                                                        rightOperand->val,
                                                        IntegerType::getTypeInt());

    node->blockInsts.addInst(leftOperand->blockInsts);
    node->blockInsts.addInst(rightOperand->blockInsts);
    node->blockInsts.addInst(mulInst);

    node->val = mulInst;

    return true;
}

bool IRGenerator::ir_div(ast_node * node)
{
    ast_node * left = node->sons[0];
    ast_node * right = node->sons[1];

    ast_node * leftOperand = ir_visit_ast_node(left);
    ast_node * rightOperand = ir_visit_ast_node(right);
    if (!leftOperand || !rightOperand) {
        return false;
    }

    BinaryInstruction * divInst = new BinaryInstruction(module->getCurrentFunction(),
                                                        IRInstOperator::IRINST_OP_DIV_I,
                                                        leftOperand->val,
                                                        rightOperand->val,
                                                        IntegerType::getTypeInt());

    node->blockInsts.addInst(leftOperand->blockInsts);
    node->blockInsts.addInst(rightOperand->blockInsts);
    node->blockInsts.addInst(divInst);

    node->val = divInst;

    return true;
}

bool IRGenerator::ir_mod(ast_node * node)
{
    ast_node * left = node->sons[0];
    ast_node * right = node->sons[1];

    ast_node * leftOperand = ir_visit_ast_node(left);
    ast_node * rightOperand = ir_visit_ast_node(right);
    if (!leftOperand || !rightOperand) {
        return false;
    }

    BinaryInstruction * modInst = new BinaryInstruction(module->getCurrentFunction(),
                                                        IRInstOperator::IRINST_OP_MOD_I,
                                                        leftOperand->val,
                                                        rightOperand->val,
                                                        IntegerType::getTypeInt());

    node->blockInsts.addInst(leftOperand->blockInsts);
    node->blockInsts.addInst(rightOperand->blockInsts);
    node->blockInsts.addInst(modInst);

    node->val = modInst;

    return true;
}

// 关系运算符处理
bool IRGenerator::ir_relational_op(ast_node * node)
{
    // 检查节点有足够的子节点
    if (node->sons.size() < 2) {
        return false;
    }

    ast_node * left = node->sons[0];
    ast_node * right = node->sons[1];
    if (!left || !right) {
        return false;
    }

    // 检查当前函数是否存在
    if (!module->getCurrentFunction()) {
        return false;
    }

    // 处理左操作数
    ast_node * leftOperand = ir_visit_ast_node(left);
    if (!leftOperand) {
        return false;
    }

    if (!leftOperand->val) {
        return false;
    }

    // 处理右操作数
    ast_node * rightOperand = ir_visit_ast_node(right);
    if (!rightOperand) {
        return false;
    }

    if (!rightOperand->val) {
        return false;
    }

    // 添加操作数的指令
    node->blockInsts.addInst(leftOperand->blockInsts);
    node->blockInsts.addInst(rightOperand->blockInsts);

    try {
        // 根据节点类型生成不同的比较指令
        BinaryInstruction * cmpInst = nullptr;
        switch (node->node_type) {
            case ast_operator_type::AST_OP_EQ:
                cmpInst = new BinaryInstruction(module->getCurrentFunction(),
                                                IRInstOperator::IRINST_OP_EQ_I,
                                                leftOperand->val,
                                                rightOperand->val,
                                                IntegerType::getTypeBool());
                break;
            case ast_operator_type::AST_OP_NE:
                cmpInst = new BinaryInstruction(module->getCurrentFunction(),
                                                IRInstOperator::IRINST_OP_NE_I,
                                                leftOperand->val,
                                                rightOperand->val,
                                                IntegerType::getTypeBool());
                break;
            case ast_operator_type::AST_OP_LT:
                cmpInst = new BinaryInstruction(module->getCurrentFunction(),
                                                IRInstOperator::IRINST_OP_LT_I,
                                                leftOperand->val,
                                                rightOperand->val,
                                                IntegerType::getTypeBool());
                break;
            case ast_operator_type::AST_OP_LE:
                cmpInst = new BinaryInstruction(module->getCurrentFunction(),
                                                IRInstOperator::IRINST_OP_LE_I,
                                                leftOperand->val,
                                                rightOperand->val,
                                                IntegerType::getTypeBool());
                break;
            case ast_operator_type::AST_OP_GT:
                cmpInst = new BinaryInstruction(module->getCurrentFunction(),
                                                IRInstOperator::IRINST_OP_GT_I,
                                                leftOperand->val,
                                                rightOperand->val,
                                                IntegerType::getTypeBool());
                break;
            case ast_operator_type::AST_OP_GE:
                cmpInst = new BinaryInstruction(module->getCurrentFunction(),
                                                IRInstOperator::IRINST_OP_GE_I,
                                                leftOperand->val,
                                                rightOperand->val,
                                                IntegerType::getTypeBool());
                break;
            default:
                return false;
        }

        if (!cmpInst) {
            return false;
        }

        // 添加比较指令
        node->blockInsts.addInst(cmpInst);

        // 直接返回比较结果
        node->val = cmpInst;
        return true;
    } catch (std::exception & e) {
        return false;
    }
}

/// @brief 检查标签是否为空，如果为空则创建一个新的标签
/// @param label 需要检查的标签
/// @return 确保不为空的标签
LabelInstruction * IRGenerator::ensureLabel(LabelInstruction * label)
{
    // 检查当前函数是否存在
    Function * currentFunc = module->getCurrentFunction();
    if (!currentFunc) {
        return nullptr;
    }

    try {
        if (label == nullptr) {
            LabelInstruction * newLabel = new LabelInstruction(currentFunc);
            if (!newLabel) {
                return nullptr;
            }
            return newLabel;
        }
        return label;
    } catch (std::exception & e) {
        return nullptr;
    }
}

// 逻辑运算符处理（短路求值）
/// @brief 逻辑与运算符处理（短路求值）
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_logical_and(ast_node * node, LabelInstruction * trueLabel, LabelInstruction * falseLabel)
{

    // 确保节点有足够的子节点
    if (node->sons.size() < 2) {
        return false;
    }

    // 确保标签不为空
    trueLabel = ensureLabel(trueLabel);
    falseLabel = ensureLabel(falseLabel);
    if (!trueLabel || !falseLabel) {
        return false;
    }

    ast_node * left = node->sons[0];
    ast_node * right = node->sons[1];
    if (!left || !right) {
        return false;
    }

    // 创建右操作数的检查标签
    LabelInstruction * rightCheckLabel = new LabelInstruction(module->getCurrentFunction());
    if (!rightCheckLabel) {
        return false;
    }

    // 处理左操作数：左操作数为真时跳转到rightCheckLabel，否则跳转到falseLabel
    // 不能直接传递trueLabel，因为还需要检查右操作数
    ast_node * leftOperand = ir_visit_ast_node(left, rightCheckLabel, falseLabel);
    if (!leftOperand) {
        return false;
    }

    if (!leftOperand->val) {

        // 创建一个临时值来避免空值错误
        try {
            LocalVariable * tempVar = static_cast<LocalVariable *>(module->newVarValue(IntegerType::getTypeBool()));
            if (!tempVar) {
                return false;
            }
            leftOperand->val = tempVar;
        } catch (std::exception & e) {
            return false;
        }
    }

    node->blockInsts.addInst(leftOperand->blockInsts);

    // 如果左操作数不是逻辑操作符，需要手动添加跳转指令
    if (left->node_type != ast_operator_type::AST_OP_LOGICAL_AND &&
        left->node_type != ast_operator_type::AST_OP_LOGICAL_OR &&
        left->node_type != ast_operator_type::AST_OP_LOGICAL_NOT) {
        try {
            addConditionalGoto(node, leftOperand->val, rightCheckLabel, falseLabel); // 使用新的辅助函数
        } catch (std::exception & e) {
            return false;
        }
    }

    // 处理右操作数
    node->blockInsts.addInst(rightCheckLabel);
    // 右操作数为真时跳转到trueLabel，否则跳转到falseLabel
    ast_node * rightOperand = ir_visit_ast_node(right, trueLabel, falseLabel);
    if (!rightOperand) {
        return false;
    }

    if (!rightOperand->val) {

        // 创建一个临时值来避免空值错误
        try {
            LocalVariable * tempVar = static_cast<LocalVariable *>(module->newVarValue(IntegerType::getTypeBool()));
            if (!tempVar) {
                return false;
            }
            rightOperand->val = tempVar;
        } catch (std::exception & e) {
            return false;
        }
    }

    node->blockInsts.addInst(rightOperand->blockInsts);

    // 如果右操作数不是逻辑操作符，需要手动添加跳转指令
    if (right->node_type != ast_operator_type::AST_OP_LOGICAL_AND &&
        right->node_type != ast_operator_type::AST_OP_LOGICAL_OR &&
        right->node_type != ast_operator_type::AST_OP_LOGICAL_NOT) {
        try {
            addConditionalGoto(node, rightOperand->val, trueLabel, falseLabel); // 使用新的辅助函数
        } catch (std::exception & e) {
            return false;
        }
    }

    // 为逻辑运算符创建一个临时值，避免后续使用时出现空值
    try {
        LocalVariable * tempVar = static_cast<LocalVariable *>(module->newVarValue(IntegerType::getTypeBool()));
        if (!tempVar) {
            return false;
        }

        // 由于我们使用了条件跳转，这个值实际上不会被用到，但设置一个非空值以避免错误
        node->val = tempVar;
    } catch (std::exception & e) {
        return false;
    }

    return true;
}

/// @brief 逻辑或运算符处理（短路求值）
/// @brief 逻辑或运算符处理（短路求值）
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_logical_or(ast_node * node, LabelInstruction * trueLabel, LabelInstruction * falseLabel)
{
    // 确保节点有足够的子节点
    if (node->sons.size() < 2) {
        return false;
    }

    // 确保标签不为空
    trueLabel = ensureLabel(trueLabel);
    falseLabel = ensureLabel(falseLabel);
    if (!trueLabel || !falseLabel) {
        return false;
    }

    ast_node * left = node->sons[0];
    ast_node * right = node->sons[1];
    if (!left || !right) {
        return false;
    }

    // 创建右操作数的检查标签
    LabelInstruction * rightCheckLabel = new LabelInstruction(module->getCurrentFunction());
    if (!rightCheckLabel) {
        return false;
    }

    // 处理左操作数：关键点是当左操作数为true时，直接跳转到trueLabel，而不是其他标签
    // 因为逻辑或的短路原则是：左侧为真，整个表达式为真
    ast_node * leftOperand = ir_visit_ast_node(left, trueLabel, rightCheckLabel);
    if (!leftOperand) {
        return false;
    }

    if (!leftOperand->val) {

        // 创建一个临时值来避免空值错误
        try {
            LocalVariable * tempVar = static_cast<LocalVariable *>(module->newVarValue(IntegerType::getTypeBool()));
            if (!tempVar) {
                return false;
            }
            leftOperand->val = tempVar;
        } catch (std::exception & e) {
            return false;
        }
    }

    node->blockInsts.addInst(leftOperand->blockInsts);

    // 如果左操作数不是逻辑操作符，需要手动添加跳转指令
    if (left->node_type != ast_operator_type::AST_OP_LOGICAL_AND &&
        left->node_type != ast_operator_type::AST_OP_LOGICAL_OR &&
        left->node_type != ast_operator_type::AST_OP_LOGICAL_NOT) {
        try {
            addConditionalGoto(node, leftOperand->val, trueLabel, rightCheckLabel); // 使用新的辅助函数
        } catch (std::exception & e) {
            return false;
        }
    }

    // 处理右操作数
    node->blockInsts.addInst(rightCheckLabel);
    ast_node * rightOperand = ir_visit_ast_node(right, trueLabel, falseLabel);
    if (!rightOperand) {
        return false;
    }

    if (!rightOperand->val) {
        // 创建一个临时值来避免空值错误
        try {
            LocalVariable * tempVar = static_cast<LocalVariable *>(module->newVarValue(IntegerType::getTypeBool()));
            if (!tempVar) {
                return false;
            }
            rightOperand->val = tempVar;
        } catch (std::exception & e) {
            return false;
        }
    }

    node->blockInsts.addInst(rightOperand->blockInsts);

    // 如果右操作数不是逻辑操作符，需要手动添加跳转指令
    if (right->node_type != ast_operator_type::AST_OP_LOGICAL_AND &&
        right->node_type != ast_operator_type::AST_OP_LOGICAL_OR &&
        right->node_type != ast_operator_type::AST_OP_LOGICAL_NOT) {
        try {
            addConditionalGoto(node, rightOperand->val, trueLabel, falseLabel); // 使用新的辅助函数
        } catch (std::exception & e) {
            return false;
        }
    }

    // 为逻辑运算符创建一个临时值，避免后续使用时出现空值
    try {
        LocalVariable * tempVar = static_cast<LocalVariable *>(module->newVarValue(IntegerType::getTypeBool()));
        if (!tempVar) {
            return false;
        }

        // 由于我们使用了条件跳转，这个值实际上不会被用到，但设置一个非空值以避免错误
        node->val = tempVar;
    } catch (std::exception & e) {
        return false;
    }

    return true;
}

/// @brief 逻辑非运算符处理
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_logical_not(ast_node * node, LabelInstruction * trueLabel, LabelInstruction * falseLabel)
{

    // 确保节点有足够的子节点
    if (node->sons.size() < 1) {
        return false;
    }

    ast_node * operand = node->sons[0];
    if (!operand) {
        return false;
    }

    // 确保标签不为空
    if (trueLabel || falseLabel) {
        trueLabel = ensureLabel(trueLabel);
        falseLabel = ensureLabel(falseLabel);
        if (!trueLabel || !falseLabel) {
            return false;
        }
    }

    // 特殊处理：如果操作数是逻辑运算符，则交换trueLabel和falseLabel后处理
    if (operand->node_type == ast_operator_type::AST_OP_LOGICAL_AND ||
        operand->node_type == ast_operator_type::AST_OP_LOGICAL_OR ||
        operand->node_type == ast_operator_type::AST_OP_LOGICAL_NOT) {

        // 如果操作数是逻辑运算符，则交换真假标签后处理
        ast_node * operandNode = ir_visit_ast_node(operand, falseLabel, trueLabel);
        if (!operandNode) {
            return false;
        }
        node->blockInsts.addInst(operandNode->blockInsts);

        // 确保有一个有效的值
        if (!operandNode->val) {
            try {
                LocalVariable * tempVar = static_cast<LocalVariable *>(module->newVarValue(IntegerType::getTypeBool()));
                if (!tempVar) {
                    return false;
                }
                node->val = tempVar;
            } catch (std::exception & e) {
                return false;
            }
        } else {
            // 不需要添加额外的跳转指令，因为内部已经处理了
            node->val = operandNode->val;
        }
        return true;
    }

    // 常规处理：计算操作数的值，然后取反
    ast_node * operandNode = ir_visit_ast_node(operand);
    if (!operandNode) {
        return false;
    }

    if (!operandNode->val) {
        // 创建一个临时值来避免空值错误
        try {
            LocalVariable * tempVar = static_cast<LocalVariable *>(module->newVarValue(IntegerType::getTypeBool()));
            if (!tempVar) {
                return false;
            }
            operandNode->val = tempVar;
        } catch (std::exception & e) {
            return false;
        }
    }

    node->blockInsts.addInst(operandNode->blockInsts);

    // 如果是条件语句中的逻辑非，使用标签跳转
    if (trueLabel && falseLabel) {

        try {
            addConditionalGoto(node, operandNode->val, falseLabel, trueLabel); // 使用新的辅助函数
        } catch (std::exception & e) {
            return false;
        }
    } else {
        // 如果是普通表达式中的逻辑非，创建单目运算指令
        try {
            UnaryInstruction * notInst = new UnaryInstruction(module->getCurrentFunction(),
                                                              IRInstOperator::IRINST_OP_LOGICAL_NOT_I,
                                                              operandNode->val,
                                                              IntegerType::getTypeBool());
            if (!notInst) {
                return false;
            }
            node->blockInsts.addInst(notInst);
            node->val = notInst;
        } catch (std::exception & e) {
            return false;
        }
    }

    return true;
}

// 控制流语句（if/while/break/continue）

/// @brief if语句处理
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_if(ast_node * node)
{
    // 确保当前函数存在
    Function * currentFunc = module->getCurrentFunction();
    if (!currentFunc) {
        return false;
    }

    // 确保节点有足够的子节点
    if (node->sons.size() < 1) {
        return false;
    }

    // if语句有两个子节点：条件表达式和语句块
    ast_node * cond = node->sons[0];
    ast_node * body = nullptr;

    // 检查是否有第二个子节点（语句体）
    if (node->sons.size() >= 2) {
        body = node->sons[1];
    }

    if (!cond) {
        return false;
    }

    try {
        // 创建标签
        LabelInstruction * trueLabel = new LabelInstruction(currentFunc);
        LabelInstruction * endLabel = new LabelInstruction(currentFunc);
        if (!trueLabel || !endLabel) {
            return false;
        }

        // 处理条件表达式
        ast_node * condNode = ir_visit_ast_node(cond, trueLabel, endLabel);
        if (!condNode) {
            return false;
        }

        // 添加条件表达式的指令
        node->blockInsts.addInst(condNode->blockInsts);

        // 如果条件表达式不是逻辑运算符，需要添加条件跳转指令
        if (cond->node_type != ast_operator_type::AST_OP_LOGICAL_AND &&
            cond->node_type != ast_operator_type::AST_OP_LOGICAL_OR &&
            cond->node_type != ast_operator_type::AST_OP_LOGICAL_NOT) {

            if (!condNode->val) {
                return false;
            }
            addConditionalGoto(node, condNode->val, trueLabel, endLabel); // 使用新的辅助函数
        }

        // 处理语句块（如果存在）
        node->blockInsts.addInst(trueLabel);

        if (body) {
            ast_node * bodyNode = ir_visit_ast_node(body);
            if (!bodyNode) {
                return false;
            }

            // 添加语句块的指令
            node->blockInsts.addInst(bodyNode->blockInsts);
        } else {
            // 如果没有语句体，添加一个空操作（nop）指令
            // 不添加任何指令，直接处理为空语句块
        }

        // 添加结束标签
        node->blockInsts.addInst(endLabel);

        return true;
    } catch (std::exception & e) {
        return false;
    }
}

/// @brief if-else语句处理
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_if_else(ast_node * node)
{
    ast_node * cond = node->sons[0];
    ast_node * ifBody = node->sons[1];
    ast_node * elseBody = node->sons[2];

    // 创建标签
    LabelInstruction * ifLabel = new LabelInstruction(module->getCurrentFunction());
    LabelInstruction * elseLabel = new LabelInstruction(module->getCurrentFunction());
    LabelInstruction * endLabel = new LabelInstruction(module->getCurrentFunction());

    // 处理条件表达式
    ast_node * condNode = ir_visit_ast_node(cond, ifLabel, elseLabel);
    if (!condNode)
        return false;
    node->blockInsts.addInst(condNode->blockInsts);

    // 如果条件表达式不是逻辑运算符，需要添加条件跳转指令
    if (cond->node_type != ast_operator_type::AST_OP_LOGICAL_AND &&
        cond->node_type != ast_operator_type::AST_OP_LOGICAL_OR &&
        cond->node_type != ast_operator_type::AST_OP_LOGICAL_NOT) {
        addConditionalGoto(node, condNode->val, ifLabel, elseLabel); // 使用新的辅助函数
    }

    // 处理if块
    node->blockInsts.addInst(ifLabel);
    ast_node * ifBodyNode = ir_visit_ast_node(ifBody);
    if (!ifBodyNode)
        return false;
    node->blockInsts.addInst(ifBodyNode->blockInsts);
    node->blockInsts.addInst(new GotoInstruction(module->getCurrentFunction(), endLabel));

    // 处理else块
    node->blockInsts.addInst(elseLabel);
    ast_node * elseBodyNode = ir_visit_ast_node(elseBody);
    if (!elseBodyNode)
        return false;
    node->blockInsts.addInst(elseBodyNode->blockInsts);

    // 结束标签
    node->blockInsts.addInst(endLabel);
    return true;
}

/// @brief while语句处理
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_while(ast_node * node)
{
    // 确保当前函数存在
    Function * currentFunc = module->getCurrentFunction();
    if (!currentFunc) {
        return false;
    }

    // 确保节点有足够的子节点
    if (node->sons.size() < 1) {
        return false;
    }

    // while语句有两个子节点：条件表达式和语句块
    ast_node * cond = node->sons[0];
    ast_node * body = nullptr;

    // 检查是否有第二个子节点（语句体）
    if (node->sons.size() >= 2) {
        body = node->sons[1];
    }

    if (!cond) {
        return false;
    }

    try {
        // 创建标签用于循环控制
        LabelInstruction * startLabel = new LabelInstruction(currentFunc);
        LabelInstruction * bodyLabel = new LabelInstruction(currentFunc);
        LabelInstruction * endLabel = new LabelInstruction(currentFunc);
        if (!startLabel || !bodyLabel || !endLabel) {
            return false;
        }

        // 保存当前循环的标签，用于break和continue
        currentFunc->pushLoopLabels(startLabel, endLabel);

        // 添加开始标签
        node->blockInsts.addInst(startLabel);

        // 处理条件表达式 - 总是传递正确的标签，不需要判断条件类型
        ast_node * condNode = ir_visit_ast_node(cond, bodyLabel, endLabel);
        if (!condNode) {
            currentFunc->popLoopLabels();
            return false;
        }

        // 添加条件表达式的指令
        node->blockInsts.addInst(condNode->blockInsts);

        // 如果条件表达式不是逻辑运算符，需要添加条件跳转指令
        if (cond->node_type != ast_operator_type::AST_OP_LOGICAL_AND &&
            cond->node_type != ast_operator_type::AST_OP_LOGICAL_OR &&
            cond->node_type != ast_operator_type::AST_OP_LOGICAL_NOT) {

            if (!condNode->val) {
                currentFunc->popLoopLabels();
                return false;
            }
            addConditionalGoto(node, condNode->val, bodyLabel, endLabel); // 使用新的辅助函数
        }

        // 添加body标签
        node->blockInsts.addInst(bodyLabel);

        // 处理语句块（如果存在）
        if (body) {
            ast_node * bodyNode = ir_visit_ast_node(body);
            if (!bodyNode) {
                currentFunc->popLoopLabels();
                return false;
            }

            // 添加语句块的指令
            node->blockInsts.addInst(bodyNode->blockInsts);
        } else {
            // 如果没有语句体，添加一个空操作（nop）指令
            // 不添加任何指令，直接处理为空语句块
        }

        // 使用br指令跳转回开始标签
        GotoInstruction * loopBackInst = new GotoInstruction(currentFunc, startLabel);
        if (!loopBackInst) {
            currentFunc->popLoopLabels();
            return false;
        }
        node->blockInsts.addInst(loopBackInst);

        // 添加结束标签
        node->blockInsts.addInst(endLabel);

        // 弹出当前循环的标签
        currentFunc->popLoopLabels();

        return true;
    } catch (std::exception & e) {
        // 确保弹出循环标签
        try {
            currentFunc->popLoopLabels();
        } catch (...) {
            // 忽略弹出标签可能的异常
        }
        return false;
    }
}

/// @brief break语句处理
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_break(ast_node * node)
{
    // 获取当前循环的结束标签
    LabelInstruction * endLabel = module->getCurrentFunction()->getCurrentLoopEndLabel();
    if (!endLabel) {
        // 不在循环中，报错
        return false;
    }

    // 使用br指令跳转到循环结束标签
    node->blockInsts.addInst(new GotoInstruction(module->getCurrentFunction(), endLabel));

    return true;
}

/// @brief continue语句处理
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_continue(ast_node * node)
{
    // 获取当前循环的开始标签
    LabelInstruction * startLabel = module->getCurrentFunction()->getCurrentLoopStartLabel();
    if (!startLabel) {
        // 不在循环中，报错
        return false;
    }

    // 使用br指令跳转到循环开始标签
    node->blockInsts.addInst(new GotoInstruction(module->getCurrentFunction(), startLabel));

    return true;
}

/// @brief return节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_return(ast_node * node)
{
    ast_node * right = nullptr;
    Value * returnValue = nullptr;

    // 获取当前函数
    Function * currentFunc = module->getCurrentFunction();
    if (!currentFunc) {
        return false;
    }

    // return语句可能没有没有表达式，也可能有，因此这里必须进行区分判断
    if (!node->sons.empty()) {
        ast_node * son_node = node->sons[0];

        // 返回的表达式的指令保存在right节点中
        right = ir_visit_ast_node(son_node);
        if (!right) {
            // 某个变量没有定值
            return false;
        }

        // 将表达式的指令添加到当前节点
        node->blockInsts.addInst(right->blockInsts);

        // 检查是否是数组元素访问，对于数组元素访问，right->val已经是加载后的值，不需要再加载
        returnValue = right->val;

        // 返回值赋值到函数返回值变量上，使用普通赋值
        MoveInstruction * moveInst = new MoveInstruction(currentFunc, currentFunc->getReturnValue(), returnValue, 0);
        node->blockInsts.addInst(moveInst);

        node->val = returnValue;
    } else {
        // 没有返回值
        node->val = nullptr;
    }

    // 跳转到函数的尾部出口指令上
    node->blockInsts.addInst(new GotoInstruction(currentFunc, currentFunc->getExitLabel()));

    return true;
}

/// @brief 类型叶子节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_leaf_node_type(ast_node * node)
{
    // 不需要做什么，直接从节点中获取即可。

    return true;
}

/// @brief 标识符叶子节点翻译成线性中间IR，变量声明的不走这个语句
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_leaf_node_var_id(ast_node * node)
{
    std::cerr << "处理变量标识符: " << node->name << std::endl;
    
    Value * val;

    // 查找ID型Value
    // 变量，则需要在符号表中查找对应的值
    val = module->findVarValue(node->name);
    if (!val) {
        std::cerr << "ir_leaf_node_var_id: 变量 " << node->name << " 未找到" << std::endl;
        return false;
    }

    node->val = val;
    std::cerr << "变量 " << node->name << " 查找成功" << std::endl;

    return true;
}

/// @brief 无符号整数字面量叶子节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_leaf_node_uint(ast_node * node)
{
    ConstInt * val;

    // 新建一个整数常量Value
    val = module->newConstInt((int32_t) node->integer_val);

    node->val = val;

    return true;
}

/// @brief 变量声明语句节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_declare_statment(ast_node * node)
{
    bool result = false;

    // 初始化指令集
    InterCode initInsts;

    for (auto & child: node->sons) {
        // 遍历每个变量声明
        if (child->sons.size() < 2) {
            return false;
        }

        // 打印调试信息

        if (child->sons[1]->node_type == ast_operator_type::AST_OP_VAR_DEF_INIT) {
            // 如果是带初始化的变量定义

            // 确保将类型信息传递给变量初始化节点
            child->sons[1]->type = child->sons[0]->type;

            result = ir_variable_declare_init(child->sons[1]);

            // 将初始化指令添加到当前节点
            initInsts.addInst(child->sons[1]->blockInsts);

            // 更新变量值
            child->val = child->sons[1]->val;
        } else if (child->sons[1]->node_type == ast_operator_type::AST_OP_ARRAY_DEF) {
            // 如果是数组定义

            // 处理数组定义
            result = ir_array_def(child->sons[1]);

            // 将数组定义指令添加到当前节点
            initInsts.addInst(child->sons[1]->blockInsts);

            // 更新变量值
            child->val = child->sons[1]->val;
        } else {
            // 普通变量声明
            result = ir_variable_declare(child);
        }

        if (!result) {
            break;
        }
    }

    // 将所有初始化指令添加到当前节点
    node->blockInsts.addInst(initInsts);

    return result;
}

/// @brief 变量定声明节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_variable_declare(ast_node * node)
{
    // 共有两个孩子，第一个类型，第二个变量名

    // 获取const属性
    bool is_const = node->is_const;

    // 创建变量时传入const标记
    Value* var = module->newVarValue(node->sons[0]->type, node->sons[1]->name, is_const);
    node->val = var;

    return true;
}

/// @brief 变量定义并初始化节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_variable_declare_init(ast_node * node)
{
    // 变量初始化节点有两个孩子：变量ID节点和初始化表达式节点
    ast_node * id_node = node->sons[0];
    ast_node * expr_node = node->sons[1];
    
    // 获取const属性
    bool is_const = node->parent ? node->parent->is_const : false;

    // 处理初始化表达式
    ast_node * expr_result = ir_visit_ast_node(expr_node);
    if (!expr_result) {
        return false;
    }

    // 创建变量 - 确保使用正确的类型
    // 如果节点自身没有类型信息，尝试从表达式结果获取类型
    Type * varType = node->type;
    if (!varType && expr_result->val) {
        varType = expr_result->val->getType();
    }

    // 如果仍然没有类型信息，默认使用整型
    if (!varType) {
        varType = IntegerType::getTypeInt();
    }

    // 创建变量时传入const标记
    Value * var = module->newVarValue(varType, id_node->name, is_const);
    node->val = var;

    // 获取当前函数
    Function * currentFunc = module->getCurrentFunction();

    // 将表达式的指令添加到当前节点
    node->blockInsts.addInst(expr_result->blockInsts);

    // 如果是全局变量初始化
    if (!currentFunc) {
        // 对于全局变量，我们需要设置其初始值
        // 目前简单处理，支持常量整数和负数常量整数初始化
        bool isConstantInit = false;
        int32_t initValue = 0;

        // 检查是否是常量整数
        if (expr_node->node_type == ast_operator_type::AST_OP_LEAF_LITERAL_UINT) {
            // 直接将整数值保存到node中
            initValue = expr_node->integer_val;
            isConstantInit = true;
        }
        // 检查是否是负数常量（负号+常量整数）
        else if (expr_node->node_type == ast_operator_type::AST_OP_NEG && expr_node->sons.size() > 0 &&
                 expr_node->sons[0]->node_type == ast_operator_type::AST_OP_LEAF_LITERAL_UINT) {
            // 负数常量初始化
            initValue = -static_cast<int32_t>(expr_node->sons[0]->integer_val);
            isConstantInit = true;
        }

        if (isConstantInit) {
            // 保存初始化值到节点中
            node->integer_val = initValue;
        } else if (dynamic_cast<ConstInt *>(expr_result->val)) {
            // 如果表达式结果是常量整数（通过ir_visit_ast_node计算得到）
            ConstInt * constVal = dynamic_cast<ConstInt *>(expr_result->val);
            initValue = constVal->getVal();
            node->integer_val = initValue;
            isConstantInit = true;
        } else {
            // 如果不是常量整数，当前简化处理，报错
            return false;
        }
    } else {
        // 局部变量初始化，添加赋值指令
        node->blockInsts.addInst(new MoveInstruction(currentFunc, var, expr_result->val));
    }

    return true;
}

/// @brief 数组定义AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_array_def(ast_node * node)
{
    // 数组定义节点应该有至少两个子节点：变量名和数组维度
    if (node->sons.size() < 2) {
        std::cerr << "ir_array_def: 子节点数量不足" << std::endl;
        return false;
    }

    // 获取变量名节点
    ast_node * id_node = node->sons[0];
    std::string array_name = id_node->name;
    std::cerr << "处理数组定义: " << array_name << std::endl;

    // 确保id_node有正确的名称
    id_node->name = array_name;

    // 获取数组元素类型和维度
    Type * elem_type = IntegerType::getTypeInt(); // 当前仅支持整型数组

    // 获取数组维度节点
    ast_node * dims_node = node->sons[1];

    // 创建一个向量存储所有维度大小
    std::vector<uint32_t> dims;

    // 当前函数
    Function * currentFunc = module->getCurrentFunction();

    if (dims_node->node_type == ast_operator_type::AST_OP_ARRAY_DIMS) {
        // 如果是AST_OP_ARRAY_DIMS类型，遍历所有子节点获取各个维度
        std::cerr << "数组维度节点类型: AST_OP_ARRAY_DIMS, 子节点数: " << dims_node->sons.size() << std::endl;
        // 遍历所有维度节点
        for (auto dim_node: dims_node->sons) {
            // 支持变量表达式和常量表达式作为数组维度
            if (dim_node->node_type == ast_operator_type::AST_OP_LEAF_LITERAL_UINT) {
                // 直接使用常量
                dims.push_back(dim_node->integer_val);
                std::cerr << "维度值(常量): " << dim_node->integer_val << std::endl;
            } else {
                // 处理表达式节点
                ast_node* expr_dim_node = ir_visit_ast_node(dim_node);
                if (!expr_dim_node) {
                    std::cerr << "ir_array_def: 处理维度表达式失败" << std::endl;
                    return false;
                }
                
                // 将维度表达式的指令添加到当前节点
                node->blockInsts.addInst(expr_dim_node->blockInsts);
                
                // 检查表达式结果是否是常量
                if (dynamic_cast<ConstInt*>(expr_dim_node->val)) {
                    // 如果是常量，直接获取其值
                    ConstInt* constVal = dynamic_cast<ConstInt*>(expr_dim_node->val);
                    uint32_t dimVal = constVal->getVal();
                    dims.push_back(dimVal);
                    std::cerr << "维度值(表达式结果): " << dimVal << std::endl;
                } else {
                    // 如果不是常量，报错
                    std::cerr << "ir_array_def: 数组维度必须是常量表达式" << std::endl;
                    return false;
                }
            }
        }
    } else if (dims_node->node_type == ast_operator_type::AST_OP_LEAF_LITERAL_UINT) {
        // 如果是单个维度
        dims.push_back(dims_node->integer_val);
        std::cerr << "单维度值: " << dims_node->integer_val << std::endl;
    } else {
        // 处理表达式维度
        ast_node* expr_dim_node = ir_visit_ast_node(dims_node);
        if (!expr_dim_node) {
            std::cerr << "ir_array_def: 处理单维度表达式失败" << std::endl;
            return false;
        }
        
        // 将维度表达式的指令添加到当前节点
        node->blockInsts.addInst(expr_dim_node->blockInsts);
        
        // 检查表达式结果是否是常量
        if (dynamic_cast<ConstInt*>(expr_dim_node->val)) {
            // 如果是常量，直接获取其值
            ConstInt* constVal = dynamic_cast<ConstInt*>(expr_dim_node->val);
            uint32_t dimVal = constVal->getVal();
            dims.push_back(dimVal);
            std::cerr << "单维度值(表达式结果): " << dimVal << std::endl;
        } else {
            // 如果不是常量，报错
            std::cerr << "ir_array_def: 数组维度必须是常量表达式" << std::endl;
            return false;
        }
    }

    // 如果没有获取到任何维度信息，报错
    if (dims.empty()) {
        std::cerr << "ir_array_def: 未获取到维度信息" << std::endl;
        return false;
    }

    // 创建数组类型
    Type * array_type = ArrayType::get(elem_type, dims);

    // 创建数组变量
    Value * array_val = nullptr;

    // 检查当前是否在函数内部
    if (currentFunc) {
        // 在函数内部，创建局部数组变量
        array_val = module->newVarValue(array_type, array_name, node->is_const);
        std::cerr << "创建局部数组变量: " << array_name << (node->is_const ? " (const)" : "") << std::endl;
    } else {
        // 在全局作用域，创建全局数组变量
        array_val = module->createGlobalArray(array_name, array_type);
        // 设置全局数组的const属性
        if (node->is_const) {
            GlobalVariable* globalArrayVar = dynamic_cast<GlobalVariable*>(array_val);
            if (globalArrayVar) {
                globalArrayVar->setConst(true);
            }
        }
        std::cerr << "创建全局数组变量: " << array_name << (node->is_const ? " (const)" : "") << std::endl;
    }

    if (!array_val) {
        std::cerr << "ir_array_def: 创建数组变量失败" << std::endl;
        return false;
    }

    // 验证变量是否正确添加到符号表
    Value* check_val = module->findVarValue(array_name);
    if (!check_val) {
        std::cerr << "ir_array_def: 变量 " << array_name << " 未正确添加到符号表" << std::endl;
        return false;
    }
    std::cerr << "变量 " << array_name << " 成功添加到符号表" << std::endl;
    
    // 计算数组总元素数量
    uint32_t total_elements = 1;
    for (auto dim : dims) {
        total_elements *= dim;
    }

    // 首先初始化所有元素为0
    if (currentFunc) {
        // 计算每个维度的元素数量
        std::vector<uint32_t> dim_sizes(dims.size());
        dim_sizes[dims.size() - 1] = 1;
        for (int i = dims.size() - 2; i >= 0; i--) {
            dim_sizes[i] = dim_sizes[i + 1] * dims[i + 1];
    }

        // 为每个元素生成初始化为0的指令
        for (uint32_t i = 0; i < total_elements; i++) {
            // 计算多维数组索引
            std::vector<uint32_t> indices;
            uint32_t remaining = i;
            for (int j = 0; j < dims.size(); j++) {
                indices.push_back(remaining / dim_sizes[j]);
                remaining %= dim_sizes[j];
    }

            // 为多维数组计算内存偏移
            Value* base_offset = module->newConstInt(0);
            
            // 计算每个维度的偏移
            for (size_t j = 0; j < indices.size(); j++) {
                // 计算当前维度的索引
                Value* idx_val = module->newConstInt(indices[j]);
                
                // 计算该维度后面的元素总数
                uint32_t elem_count = 1;
                for (size_t k = j + 1; k < dims.size(); k++) {
                    elem_count *= dims[k];
                }
                Value* dim_size = module->newConstInt(elem_count);
                
                // 计算当前维度的偏移: idx * dim_size
                BinaryInstruction* dim_offset = new BinaryInstruction(
                    currentFunc,
                    IRInstOperator::IRINST_OP_MUL_I,
                    idx_val,
                    dim_size,
                    IntegerType::getTypeInt()
                );
                node->blockInsts.addInst(dim_offset);

                // 累加偏移
                BinaryInstruction* new_offset = new BinaryInstruction(
                    currentFunc,
                    IRInstOperator::IRINST_OP_ADD_I,
                    base_offset,
                    dim_offset,
                    IntegerType::getTypeInt()
                );
                node->blockInsts.addInst(new_offset);
                base_offset = new_offset;
    }

            // 计算字节偏移: offset * 元素大小(4)
            ConstInt* elem_size = module->newConstInt(4);
            BinaryInstruction* byte_offset = new BinaryInstruction(
                currentFunc, 
                IRInstOperator::IRINST_OP_MUL_I,
                base_offset,
                elem_size,
                IntegerType::getTypeInt()
            );
            node->blockInsts.addInst(byte_offset);
            
            // 计算元素地址: array_base + byte_offset
            BinaryInstruction* addr_inst = new BinaryInstruction(
                currentFunc,
                IRInstOperator::IRINST_OP_ADD_I,
                array_val,
                byte_offset,
                IntegerType::getTypeInt()
            );
            node->blockInsts.addInst(addr_inst);
            
            // 使用MoveInstruction来实现存储操作，初始化为0
            ConstInt* zero_val = module->newConstInt(0);
            MoveInstruction* store_inst = new MoveInstruction(
                currentFunc,
                addr_inst,
                zero_val,
                1  // 操作类型为存储操作
            );
            node->blockInsts.addInst(store_inst);
        }
    }
    
    // 处理初始化（如果有的话）
    if (node->sons.size() >= 3) {
        if (!currentFunc) {
            // 全局数组的初始化支持
            std::cerr << "处理全局数组初始化" << std::endl;
            
            // 获取初始化节点
            ast_node * init_node = node->sons[2];
            
            // 处理空初始化 {}
            if (init_node->node_type == ast_operator_type::AST_OP_ARRAY_INIT_EMPTY) {
                // 对于空初始化，全局数组已经默认初始化为0
                std::cerr << "全局数组空初始化" << std::endl;
                // 不需要额外操作
            }
            // 处理初始化列表
            else if (init_node->node_type == ast_operator_type::AST_OP_ARRAY_INIT_LIST) {
                // 全局数组初始化只支持常量初始化
                std::cerr << "处理全局数组初始化列表" << std::endl;
                
                // 将所有初始化元素存入一个临时数组
                std::vector<ast_node*> init_elements;
                collectInitElements(init_node, init_elements, dims);
                
                // 检查初始化列表中的元素数量
                size_t init_count = init_elements.size();
                std::cerr << "全局初始化元素数: " << init_count << std::endl;
                if (init_count > total_elements) {
                    std::cerr << "ir_array_def: 全局初始化元素太多" << std::endl;
                    return false; // 初始化元素太多
                }
                
                // 获取全局数组变量
                GlobalVariable* globalArrayVar = dynamic_cast<GlobalVariable*>(array_val);
                if (!globalArrayVar) {
                    std::cerr << "ir_array_def: 全局数组变量类型转换失败" << std::endl;
                    return false;
                }
                
                // 处理每个初始化元素，添加到全局变量的initializer中
                // (在真实实现中，这应该在Module::createGlobalArray中完成)
                // 这里只是一个简单的模拟实现
                std::vector<int32_t> initialValues;
                for (size_t i = 0; i < init_count; ++i) {
                    ast_node* elem_node = init_elements[i];
                    if (elem_node && elem_node->node_type == ast_operator_type::AST_OP_ARRAY_INIT_ELEM) {
                        ast_node* expr_node = elem_node->sons[0];
                        if (expr_node->node_type == ast_operator_type::AST_OP_LEAF_LITERAL_UINT) {
                            // 常量整数
                            initialValues.push_back(expr_node->integer_val);
                        } else if (expr_node->node_type == ast_operator_type::AST_OP_NEG && 
                                  expr_node->sons[0]->node_type == ast_operator_type::AST_OP_LEAF_LITERAL_UINT) {
                            // 负数常量
                            initialValues.push_back(-static_cast<int32_t>(expr_node->sons[0]->integer_val));
                        } else {
                            std::cerr << "ir_array_def: 全局数组只支持常量初始化" << std::endl;
                            return false;
                        }
                    } else {
                        // 空元素，初始化为0
                        initialValues.push_back(0);
                    }
                }
                
                // 补齐剩余元素为0
                for (size_t i = initialValues.size(); i < total_elements; ++i) {
                    initialValues.push_back(0);
                }
                
                // 设置初始化值（这里假设GlobalVariable有一个设置初始值的方法）
                // globalArrayVar->setInitialValues(initialValues);
                
                std::cerr << "全局数组初始化完成" << std::endl;
            } else {
                std::cerr << "ir_array_def: 不支持的全局数组初始化类型" << std::endl;
                return false;
            }
        } else {
            // 局部数组初始化处理
            
            // 获取初始化节点
            ast_node * init_node = node->sons[2];
            std::cerr << "处理数组初始化节点, 类型: " << (int)init_node->node_type << std::endl;
            
            // 先处理初始化节点
            ast_node * init_processed = ir_visit_ast_node(init_node);
            if (!init_processed) {
                std::cerr << "ir_array_def: 处理初始化节点失败" << std::endl;
                return false;
            }

            // 添加初始化节点的指令
            node->blockInsts.addInst(init_processed->blockInsts);
            
            // 处理空初始化 {}
            if (init_node->node_type == ast_operator_type::AST_OP_ARRAY_INIT_EMPTY) {
                // 对于空初始化，不需要做额外的操作，数组已经初始化为0了
                std::cerr << "处理空数组初始化" << std::endl;
            }
            // 处理初始化列表
            else if (init_node->node_type == ast_operator_type::AST_OP_ARRAY_INIT_LIST) {
                std::cerr << "处理数组初始化列表" << std::endl;
                
                // 将所有初始化元素存入一个临时数组，以便后续处理
                std::vector<ast_node*> init_elements;
                collectInitElements(init_node, init_elements, dims);
                
                // 检查初始化列表中的元素数量
                size_t init_count = init_elements.size();
                std::cerr << "初始化元素数: " << init_count << std::endl;
                if (init_count > total_elements) {
                    std::cerr << "ir_array_def: 初始化元素太多" << std::endl;
                    return false; // 初始化元素太多
                }
                
                // 计算每个维度的元素数量
                std::vector<uint32_t> dim_sizes(dims.size());
                dim_sizes[dims.size() - 1] = 1;
                for (int i = dims.size() - 2; i >= 0; i--) {
                    dim_sizes[i] = dim_sizes[i + 1] * dims[i + 1];
        }

                // 为每个初始化元素生成存储指令
                for (size_t i = 0; i < init_count; i++) {
                    ast_node* elem_node = init_elements[i];
                    if (!elem_node || !elem_node->val) {
                        std::cerr << "初始化元素 " << i << " 无效或为空（保持为0）" << std::endl;
                        continue; // 跳过空元素，保持默认值0
                    }
                    
                    std::cerr << "处理初始化元素 " << i << std::endl;
                    
                    // 计算多维数组索引
                    std::vector<uint32_t> indices;
                    uint32_t remaining = i;
                    for (int j = 0; j < dims.size(); j++) {
                        indices.push_back(remaining / dim_sizes[j]);
                        remaining %= dim_sizes[j];
        }

                    // 为多维数组计算内存偏移
                    Value* base_offset = module->newConstInt(0);
                    
                    // 计算每个维度的偏移
                    for (size_t j = 0; j < indices.size(); j++) {
                        // 计算当前维度的索引
                        Value* idx_val = module->newConstInt(indices[j]);

                        // 计算该维度后面的元素总数
                        uint32_t elem_count = 1;
                        for (size_t k = j + 1; k < dims.size(); k++) {
                            elem_count *= dims[k];
        }
                        Value* dim_size = module->newConstInt(elem_count);
                        
                        // 计算当前维度的偏移: idx * dim_size
                        BinaryInstruction* dim_offset = new BinaryInstruction(
                            currentFunc,
                            IRInstOperator::IRINST_OP_MUL_I,
                            idx_val,
                            dim_size,
                            IntegerType::getTypeInt()
                        );
                        node->blockInsts.addInst(dim_offset);

                        // 累加偏移
                        BinaryInstruction* new_offset = new BinaryInstruction(
                            currentFunc,
                            IRInstOperator::IRINST_OP_ADD_I,
                            base_offset,
                            dim_offset,
                            IntegerType::getTypeInt()
                        );
                        node->blockInsts.addInst(new_offset);
                        base_offset = new_offset;
        }

                        // 计算字节偏移: offset * 元素大小(4)
                        ConstInt* elem_size = module->newConstInt(4);
                        BinaryInstruction* byte_offset = new BinaryInstruction(
                            currentFunc, 
                                                                IRInstOperator::IRINST_OP_MUL_I,
                            base_offset,
                                                                elem_size,
                            IntegerType::getTypeInt()
                        );
            if (!byte_offset) {
                        std::cerr << "创建字节偏移指令失败" << std::endl;
            return false;
        }
        node->blockInsts.addInst(byte_offset);

                        // 计算元素地址: array_base + byte_offset
                        BinaryInstruction* addr_inst = new BinaryInstruction(
                            currentFunc,
                                                              IRInstOperator::IRINST_OP_ADD_I,
                            array_val,
                                                              byte_offset,
                            IntegerType::getTypeInt()  // 使用整型作为类型
        );
            if (!addr_inst) {
                        std::cerr << "创建地址计算指令失败" << std::endl;
            return false;
        }
        node->blockInsts.addInst(addr_inst);

                        // 使用MoveInstruction来实现存储操作
                        MoveInstruction* store_inst = new MoveInstruction(
                            currentFunc,
                            addr_inst,  // 目标地址
                            elem_node->val,  // 要存储的值
                            1  // 操作类型为存储操作
                        );
                        if (!store_inst) {
                            std::cerr << "创建存储指令失败" << std::endl;
                            return false;
                        }
                        node->blockInsts.addInst(store_inst);
                    }
                }
            }
        }
    }

    // 设置节点的值
    node->val = array_val;
    std::cerr << "数组定义处理完成: " << array_name << std::endl;

    return true;
}

// 辅助函数：收集初始化元素
void IRGenerator::collectInitElements(ast_node* init_node, std::vector<ast_node*>& elements, const std::vector<uint32_t>& dims, size_t current_dim) {
    if (!init_node) return;
    
    // 获取当前维度的大小
    uint32_t dim_size = (current_dim < dims.size()) ? dims[current_dim] : 0;
    
    // 计算当前维度的每个元素包含多少个子元素
    size_t sub_elements = 1;
    for (size_t i = current_dim + 1; i < dims.size(); i++) {
        sub_elements *= dims[i];
    }
    
    if (init_node->node_type == ast_operator_type::AST_OP_ARRAY_INIT_LIST) {
        size_t start_pos = elements.size();
        
        // 处理每个子初始化器
        for (size_t i = 0; i < init_node->sons.size() && i < dim_size * (current_dim == dims.size() - 1 ? 1 : sub_elements); i++) {
            ast_node* son = init_node->sons[i];
            
            if (son->node_type == ast_operator_type::AST_OP_ARRAY_INIT_LIST) {
                // 嵌套列表，如 {3} 或 {5}
                if (current_dim < dims.size() - 1) {
                    // 检查是否是单元素初始化器，如 {3} 或 {5}
                    if (son->sons.size() == 1 && son->sons[0]->node_type == ast_operator_type::AST_OP_ARRAY_INIT_ELEM) {
                        // 单元素初始化器只初始化第一个子元素
                        elements.push_back(son->sons[0]);
                        
                        // 其余子元素保持为0
                        for (size_t j = 1; j < dims[current_dim + 1]; j++) {
                            elements.push_back(nullptr);
                        }
                    } else {
                        // 正常的嵌套初始化列表，递归处理
                        collectInitElements(son, elements, dims, current_dim + 1);
                    }
                } else {
                    // 最内层维度不应该有嵌套列表
                    elements.push_back(nullptr);
                }
            } else if (son->node_type == ast_operator_type::AST_OP_ARRAY_INIT_ELEM) {
                // 单个元素
                elements.push_back(son);
            }
        }
        
        // 如果初始化器数量不足，填充剩余空间
        size_t initialized = elements.size() - start_pos;
        size_t expected;
        if (current_dim == dims.size() - 1) {
            expected = dim_size;
        } else {
            expected = dim_size * sub_elements;
        }
        
        for (size_t i = initialized; i < expected; i++) {
            elements.push_back(nullptr);
        }
    } else if (init_node->node_type == ast_operator_type::AST_OP_ARRAY_INIT_ELEM) {
        // 单个元素，直接添加
        elements.push_back(init_node);
    }
}

/// @brief 数组访问AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_array_access(ast_node * node)
{
    // 数组访问节点应该有两个子节点：数组名和索引列表
    if (node->sons.size() < 2) {
        std::cerr << "ir_array_access: 子节点数量不足" << std::endl;
        return false;
    }

    // 获取当前函数
    Function * currentFunc = module->getCurrentFunction();
    if (!currentFunc) {
        std::cerr << "ir_array_access: 当前无函数上下文" << std::endl;
        return false;
    }

    // 获取数组名节点
    ast_node * array_id_node = node->sons[0];
    if (!array_id_node) {
        std::cerr << "ir_array_access: 数组名节点为空" << std::endl;
        return false;
    }

    std::cerr << "处理数组访问: " << array_id_node->name << std::endl;

    // 处理数组标识符节点
    ast_node* processed_array_node = ir_visit_ast_node(array_id_node);
    if (!processed_array_node) {
        std::cerr << "ir_array_access: 处理数组标识符节点失败" << std::endl;
            return false;
        }

    // 将数组标识符节点的指令添加到当前节点
    node->blockInsts.addInst(processed_array_node->blockInsts);

    // 获取数组变量
    Value * array_var = processed_array_node->val;
    if (!array_var) {
        std::cerr << "ir_array_access: 数组变量为空" << std::endl;
            return false;
        }

    // 设置数组标识符节点的值
    array_id_node->val = array_var;

    // 获取索引节点
    ast_node * indices_node = node->sons[1];
    if (!indices_node || indices_node->sons.empty()) {
        std::cerr << "ir_array_access: 索引节点为空或无子节点" << std::endl;
            return false;
        }

    std::cerr << "数组索引数量: " << indices_node->sons.size() << std::endl;

    // 获取数组类型信息
    ArrayType * array_type = nullptr;
    if (array_var->getType()->isArrayType()) {
        array_type = static_cast<ArrayType *>(array_var->getType());
    } else {
        std::cerr << "ir_array_access: 不是数组类型" << std::endl;
            return false;
        }

    // 获取数组维度
    const std::vector<uint32_t> & dimensions = array_type->getDimensions();
    if (dimensions.empty()) {
        std::cerr << "ir_array_access: 数组维度为空" << std::endl;
            return false;
        }

    std::cerr << "数组维度: ";
    for (auto dim : dimensions) {
        std::cerr << dim << " ";
    }
    std::cerr << std::endl;

    // 如果索引数量与数组维度不匹配
    if (indices_node->sons.size() != dimensions.size()) {
        std::cerr << "索引数量与维度不匹配: 索引=" << indices_node->sons.size() << ", 维度=" << dimensions.size() << std::endl;
        // 对于像a[k]这样的部分索引，我们将其视为子数组指针，这对于传递给函数很有用
        // 如果索引数量大于维度，仍然是错误
        if (indices_node->sons.size() > dimensions.size()) {
            std::cerr << "ir_array_access: 索引数量大于维度数量" << std::endl;
            return false;
        }
    }

    // 计算数组元素偏移
    Value* offset = module->newConstInt(0);
    
    // 处理每个维度的索引
    for (size_t i = 0; i < indices_node->sons.size(); i++) {
        // 处理索引表达式
        ast_node* index_expr = ir_visit_ast_node(indices_node->sons[i]);
        if (!index_expr || !index_expr->val) {
            std::cerr << "ir_array_access: 处理索引表达式失败, 索引=" << i << std::endl;
            return false;
        }
        
        std::cerr << "处理索引 " << i << std::endl;
        
        // 将索引表达式的指令添加到当前节点
        node->blockInsts.addInst(index_expr->blockInsts);
        
        // 计算该维度后面的元素总数
        uint32_t elem_count = 1;
        for (size_t k = i + 1; k < dimensions.size(); k++) {
            elem_count *= dimensions[k];
        }
        Value* dim_size = module->newConstInt(elem_count);
        
        // 计算当前维度的偏移: index * dim_size
        BinaryInstruction* dim_offset = new BinaryInstruction(
            currentFunc,
            IRInstOperator::IRINST_OP_MUL_I,
            index_expr->val,
            dim_size,
            IntegerType::getTypeInt()
        );
        if (!dim_offset) {
            std::cerr << "ir_array_access: 创建乘法指令失败" << std::endl;
        return false;
    }
        node->blockInsts.addInst(dim_offset);
        
        // 累加偏移
        BinaryInstruction* new_offset = new BinaryInstruction(
            currentFunc,
            IRInstOperator::IRINST_OP_ADD_I,
            offset,
            dim_offset,
            IntegerType::getTypeInt()
        );
        if (!new_offset) {
            std::cerr << "ir_array_access: 创建加法指令失败" << std::endl;
            return false;
        }
        node->blockInsts.addInst(new_offset);
        offset = new_offset;
    }
    
    // 计算字节偏移: offset * 元素大小(4)
    ConstInt* elem_size = module->newConstInt(4);
    BinaryInstruction* byte_offset = new BinaryInstruction(
        currentFunc, 
                                                            IRInstOperator::IRINST_OP_MUL_I,
                                                            offset,
                                                            elem_size,
        IntegerType::getTypeInt()
    );
    if (!byte_offset) {
        std::cerr << "ir_array_access: 创建字节偏移指令失败" << std::endl;
        return false;
    }
    node->blockInsts.addInst(byte_offset);

    // 检查当前节点是否用于赋值操作左侧
    ast_node * parent = node->parent;

    // 如果是部分索引(子数组)或是赋值左侧，返回指针
    if ((indices_node->sons.size() < dimensions.size()) ||
        (parent && parent->node_type == ast_operator_type::AST_OP_ASSIGN && parent->sons[0] == node)) {
        std::cerr << "数组访问用于赋值左侧或部分索引" << std::endl;
        // 创建一个临时变量来存储数组元素地址
        LocalVariable* addr_temp = static_cast<LocalVariable*>(module->newVarValue(IntegerType::getTypeInt()));
        if (!addr_temp) {
            std::cerr << "ir_array_access: 创建临时变量失败" << std::endl;
            return false;
        }
        
        // 计算元素地址: array_base + byte_offset
        BinaryInstruction* addr_inst = new BinaryInstruction(
            currentFunc,
            IRInstOperator::IRINST_OP_ADD_I,
            array_var,
            byte_offset,
            IntegerType::getTypeInt()  // 使用整型作为类型
        );
        if (!addr_inst) {
            std::cerr << "ir_array_access: 创建地址计算指令失败" << std::endl;
            return false;
        }
        node->blockInsts.addInst(addr_inst);
        
        // 返回指针，供赋值或作为数组参数使用
        node->val = addr_inst;
    } else {
        std::cerr << "数组访问用于加载值" << std::endl;
        // 不是赋值左侧，需要加载数组元素的值
        try {
            // 创建临时变量存储加载的值
            LocalVariable * load_temp = static_cast<LocalVariable *>(module->newVarValue(IntegerType::getTypeInt()));
            if (!load_temp) {
                std::cerr << "ir_array_access: 创建加载临时变量失败" << std::endl;
                return false;
            }
            
            // 计算元素地址: array_base + byte_offset
            BinaryInstruction* addr_inst = new BinaryInstruction(
                currentFunc,
                IRInstOperator::IRINST_OP_ADD_I,
                array_var,
                byte_offset,
                IntegerType::getTypeInt()  // 使用整型作为类型
            );
            if (!addr_inst) {
                std::cerr << "ir_array_access: 创建地址计算指令失败" << std::endl;
                return false;
            }
            node->blockInsts.addInst(addr_inst);

            // 创建加载指令：value = *addr
            MoveInstruction * load_inst = new MoveInstruction(
                currentFunc,
                load_temp,  // 临时变量存储加载值
                addr_inst,  // 数组元素地址
                2           // opType=2表示加载操作
            );
            
            if (!load_inst) {
                std::cerr << "ir_array_access: 创建加载指令失败" << std::endl;
                return false;
            }
            node->blockInsts.addInst(load_inst);

            // 将临时变量设置为节点的值
            node->val = load_temp;
            std::cerr << "数组元素加载完成" << std::endl;
        } catch (std::exception & e) {
            std::cerr << "ir_array_access: 异常: " << e.what() << std::endl;
            return false;
        }
    }

    std::cerr << "数组访问处理完成" << std::endl;
    return true;
}

// 新增的辅助函数实现
Value * IRGenerator::ensureConditionIsRegister(ast_node * instructionNode, Value * condValue)
{
    Function * currentFunc = module->getCurrentFunction();
    if (!currentFunc) {
        return nullptr;
    }

    ConstInt * constIntCond = dynamic_cast<ConstInt *>(condValue);
    if (constIntCond) {
        // 如果条件是常量，将其加载到一个 i32 临时寄存器
        LocalVariable * tempReg = static_cast<LocalVariable *>(module->newVarValue(IntegerType::getTypeInt()));
        if (!tempReg) {
            return nullptr;
        }
        MoveInstruction * moveInst = new MoveInstruction(currentFunc, tempReg, constIntCond);
        instructionNode->blockInsts.addInst(moveInst); // Add to the instruction list of the AST node being processed
        return tempReg;
    }
    // 如果不是 ConstInt，或者已经是寄存器（如 BinaryInstruction 的结果），直接使用
    return condValue;
}

void IRGenerator::addConditionalGoto(ast_node * instructionNode,
                                     Value * condValue,
                                     LabelInstruction * trueLabel,
                                     LabelInstruction * falseLabel)
{
    Function * currentFunc = module->getCurrentFunction();
    if (!currentFunc) {
        return;
    }

    Value * processedCondValue = ensureConditionIsRegister(instructionNode, condValue);
    if (!processedCondValue) {
        return;
    }

    GotoInstruction * gotoInst = new GotoInstruction(currentFunc, trueLabel, falseLabel, processedCondValue);
    instructionNode->blockInsts.addInst(gotoInst);
}

/// @brief 空数组初始化AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_array_init_empty(ast_node * node)
{
    // 空数组初始化节点应该是AST_OP_ARRAY_DEF节点的子节点
    // 此处只需将标记设置到父节点，实际的初始化会在ir_array_def中处理
    
    // 设置node->val为nullptr，表示这是一个空初始化
    node->val = nullptr;
    return true;
}

/// @brief 数组初始化元素AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_array_init_elem(ast_node * node)
{
    // 数组初始化元素节点应该有一个子节点，是一个表达式
    if (node->sons.empty()) {
        return false;
    }

    // 处理表达式节点
    ast_node * expr_node = ir_visit_ast_node(node->sons[0]);
    if (!expr_node || !expr_node->val) {
        return false;
    }

    // 将表达式的指令添加到当前节点
    node->blockInsts.addInst(expr_node->blockInsts);

    // 将表达式的值设置为当前节点的值
    node->val = expr_node->val;

    return true;
}

/// @brief 数组初始化列表AST节点翻译成线性中间IR
/// @param node AST节点
/// @return 翻译是否成功，true：成功，false：失败
bool IRGenerator::ir_array_init_list(ast_node * node)
{
    // 数组初始化列表节点包含多个初始化元素
    // 处理每个初始化元素
    for (auto son : node->sons) {
        ast_node * elem_node = ir_visit_ast_node(son);
        if (!elem_node) {
            return false;
        }

        // 将元素的指令添加到当前节点
        node->blockInsts.addInst(elem_node->blockInsts);
    }

    return true;
}